package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.37

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/weeb-vip/anime-api/graph/generated"
	"github.com/weeb-vip/anime-api/graph/model"
	"github.com/weeb-vip/anime-api/internal/resolvers"
)

// Tags is the resolver for the tags field.
func (r *animeResolver) Tags(ctx context.Context, obj *model.Anime) ([]string, error) {
	// Check if tags are already preloaded
	if obj.Tags != nil {
		return obj.Tags, nil
	}

	// Fetch tags from the anime_tags junction table
	tags, err := r.AnimeTagRepository.GetTagNamesForAnime(obj.ID)
	if err != nil {
		return nil, err
	}
	return tags, nil
}

// Episodes is the resolver for the episodes field.
func (r *animeResolver) Episodes(ctx context.Context, obj *model.Anime) ([]*model.Episode, error) {
	// Check if episodes are already in the Episodes field (preloaded)
	// This should be set by transformAnimeToGraphQL when episodes are preloaded
	if obj.Episodes != nil {
		return obj.Episodes, nil
	}

	// Check if this is coming from a seasonal anime query - return empty array to avoid N+1 queries
	if isSeasonalAnimeQuery(ctx) {
		return []*model.Episode{}, nil
	}

	// Fallback to individual query if not preloaded and not from seasonal query
	animeID := obj.ID
	return resolvers.EpisodesByAnimeID(ctx, r.AnimeEpisodeService, animeID)
}

// Seasons is the resolver for the seasons field.
func (r *animeResolver) Seasons(ctx context.Context, obj *model.Anime) ([]*model.AnimeSeason, error) {
	animeID := obj.ID
	return resolvers.AnimeSeasons(ctx, r.AnimeSeasonService, animeID)
}

// NextEpisode is the resolver for the nextEpisode field.
func (r *animeResolver) NextEpisode(ctx context.Context, obj *model.Anime) (*model.Episode, error) {
	if obj.NextEpisode != nil {
		return obj.NextEpisode, nil
	}
	animeID := obj.ID
	return resolvers.NextEpisode(ctx, r.AnimeEpisodeService, animeID)
}

// AnimeAPI is the resolver for the animeApi field.
func (r *apiInfoResolver) AnimeAPI(ctx context.Context, obj *model.APIInfo) (*model.AnimeAPI, error) {
	return resolvers.AnimeAPI(r.Config)
}

// Anime is the resolver for the anime field.
func (r *userAnimeResolver) Anime(ctx context.Context, obj *model.UserAnime) (*model.Anime, error) {
	animeID := obj.AnimeID
	return resolvers.AnimeByID(ctx, r.AnimeService, animeID)
}

// Anime returns generated.AnimeResolver implementation.
func (r *Resolver) Anime() generated.AnimeResolver { return &animeResolver{r} }

// ApiInfo returns generated.ApiInfoResolver implementation.
func (r *Resolver) ApiInfo() generated.ApiInfoResolver { return &apiInfoResolver{r} }

// UserAnime returns generated.UserAnimeResolver implementation.
func (r *Resolver) UserAnime() generated.UserAnimeResolver { return &userAnimeResolver{r} }

type animeResolver struct{ *Resolver }
type apiInfoResolver struct{ *Resolver }
type userAnimeResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func isSeasonalAnimeQuery(ctx context.Context) bool {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return false
	}

	// Traverse up the field context to find the root field
	current := fc
	for current.Parent != nil {
		current = current.Parent
	}

	// Check if the root field is one of the seasonal anime queries
	if current.Field.Field == nil {
		return false
	}
	rootField := current.Field.Name
	return rootField == "animeBySeasons" || rootField == "animeBySeasonAndYear"
}
