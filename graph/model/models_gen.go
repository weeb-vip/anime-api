// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

// Anime Type
type Anime struct {
	// ID of the anime
	ID string `json:"id"`
	// AniDB ID of the anime
	Anidbid *string `json:"anidbid,omitempty"`
	// English titel the anime
	TitleEn *string `json:"titleEn,omitempty"`
	// Japanese titel the anime
	TitleJp *string `json:"titleJp,omitempty"`
	// Romaji titel the anime
	TitleRomaji *string `json:"titleRomaji,omitempty"`
	// Kanji titel the anime
	TitleKanji *string `json:"titleKanji,omitempty"`
	// Synonyms of the anime
	TitleSynonyms []string `json:"titleSynonyms,omitempty"`
	// Description of the anime
	Description *string `json:"description,omitempty"`
	// Image URL of the anime
	ImageURL *string `json:"imageUrl,omitempty"`
	// Tags of the anime
	Tags []string `json:"tags,omitempty"`
	// Studios of the anime
	Studios []string `json:"studios,omitempty"`
	// Anime status (finished, airing, upcoming)
	AnimeStatus *string `json:"animeStatus,omitempty"`
	// Anime episode count
	EpisodeCount *int `json:"episodeCount,omitempty"`
	// returns all episodes of the anime
	Episodes []*Episode `json:"episodes,omitempty"`
	// Anime episode duration
	Duration *string `json:"duration,omitempty"`
	// Anime rating
	Rating *string `json:"rating,omitempty"`
	// Anime first air date
	StartDate *time.Time `json:"startDate,omitempty"`
	// Anime last air date
	EndDate *time.Time `json:"endDate,omitempty"`
	// Anime broadcast
	Broadcast *string `json:"broadcast,omitempty"`
	// Anime source (myanimelist, anime-planet, anidb, anilist, kitsu, anime_news_network)
	Source *string `json:"source,omitempty"`
	// Anime licensors
	Licensors []string `json:"licensors,omitempty"`
	// Anime rank
	Ranking *int `json:"ranking,omitempty"`
	// Anime seasons
	Seasons     []*AnimeSeason `json:"seasons,omitempty"`
	CreatedAt   string         `json:"createdAt"`
	UpdatedAt   string         `json:"updatedAt"`
	NextEpisode *Episode       `json:"nextEpisode,omitempty"`
}

func (Anime) IsEntity() {}

type AnimeAPI struct {
	// Version of event anime-api service
	Version string `json:"version"`
}

type AnimeCharacter struct {
	// Unique identifier for the character
	ID string `json:"id"`
	// The ID of the anime this character belongs to
	AnimeID string `json:"animeId"`
	// Name of the character
	Name string `json:"name"`
	// The role of the character (e.g., main, supporting)
	Role string `json:"role"`
	// The character's birthdate (if known)
	Birthday *string `json:"birthday,omitempty"`
	// The character's zodiac sign (if known)
	Zodiac *string `json:"zodiac,omitempty"`
	// The character's gender (e.g., male, female, non-binary)
	Gender *string `json:"gender,omitempty"`
	// The character's race (e.g., human, elf, demon)
	Race *string `json:"race,omitempty"`
	// The character's height
	Height *string `json:"height,omitempty"`
	// The character's weight
	Weight *string `json:"weight,omitempty"`
	// The character's title (e.g., 'The Hero', 'The King')
	Title *string `json:"title,omitempty"`
	// The character's marital status (e.g., single, married, unknown)
	MartialStatus *string `json:"martialStatus,omitempty"`
	// A brief summary of the character's background or story
	Summary *string `json:"summary,omitempty"`
	// URL or path to the character's image
	Image *string `json:"image,omitempty"`
	// Timestamp when the character was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	// Timestamp when the character was last updated in the database
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	// The voice actor for the character
	Staff []*AnimeStaff `json:"staff,omitempty"`
}

type AnimeSearchInput struct {
	// Search query
	Query string `json:"query"`
	// Page number
	Page int `json:"page"`
	// Items per page
	PerPage int `json:"perPage"`
	// Sort by
	SortBy *string `json:"sortBy,omitempty"`
	// Sort direction
	SortDirection *string `json:"sortDirection,omitempty"`
	// Tags
	Tags []string `json:"tags,omitempty"`
	// Studios
	Studios []string `json:"studios,omitempty"`
	// Anime statuses
	AnimeStatuses []string `json:"animeStatuses,omitempty"`
}

type AnimeSeason struct {
	// ID of the anime season
	ID string `json:"id"`
	// Season identifier (e.g., SPRING_2024)
	Season Season `json:"season"`
	// Status of the anime season
	Status AnimeSeasonStatus `json:"status"`
	// Episode count for this season
	EpisodeCount *int `json:"episodeCount,omitempty"`
	// Additional notes about this season
	Notes *string `json:"notes,omitempty"`
	// Anime ID this season belongs to
	AnimeID   *string   `json:"animeId,omitempty"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

type AnimeStaff struct {
	// Unique identifier for the staff member
	ID string `json:"id"`
	// The given name of the staff member
	GivenName string `json:"givenName"`
	// Staff Language
	Language *string `json:"language,omitempty"`
	// The family name of the staff member
	FamilyName string `json:"familyName"`
	// URL or path to the staff member's image
	Image *string `json:"image,omitempty"`
	// The staff member's birthdate (if known)
	Birthday *string `json:"birthday,omitempty"`
	// The staff member's birthplace (if known)
	BirthPlace *string `json:"birthPlace,omitempty"`
	// The staff member's blood type (if known)
	BloodType *string `json:"bloodType,omitempty"`
	// The staff member's hobbies (if known)
	Hobbies *string `json:"hobbies,omitempty"`
	// A brief summary of the staff member's background or career
	Summary *string `json:"summary,omitempty"`
	// Timestamp when the staff member was created in the database
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	// Timestamp when the staff member was last updated in the database
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`
	// the characters associated with the staff member
	Characters []*AnimeCharacter `json:"characters,omitempty"`
}

type APIInfo struct {
	// API Info of the AnimeAPI
	AnimeAPI *AnimeAPI `json:"animeApi"`
	// Name of the API
	Name string `json:"name"`
}

type CharacterWithStaff struct {
	// The character details
	Character *AnimeCharacter `json:"character"`
	// The staff member associated with the character
	Staff []*AnimeStaff `json:"staff,omitempty"`
}

type CurrentlyAiringInput struct {
	// start date
	StartDate time.Time `json:"startDate"`
	// end date
	EndDate *time.Time `json:"endDate,omitempty"`
	// days in the future
	DaysInFuture *int `json:"daysInFuture,omitempty"`
}

type Episode struct {
	// ID of the episode
	ID string `json:"id"`
	// Anime ID of the episode
	AnimeID *string `json:"animeId,omitempty"`
	// Episode number
	EpisodeNumber *int `json:"episodeNumber,omitempty"`
	// Episode title
	TitleEn *string `json:"titleEn,omitempty"`
	// Episode title
	TitleJp *string `json:"titleJp,omitempty"`
	// Episode synopsis
	Synopsis *string `json:"synopsis,omitempty"`
	// Episode air date
	AirDate   *time.Time `json:"airDate,omitempty"`
	CreatedAt string     `json:"createdAt"`
	UpdatedAt string     `json:"updatedAt"`
}

func (Episode) IsEntity() {}

type UserAnime struct {
	AnimeID string `json:"animeID"`
	Anime   *Anime `json:"anime,omitempty"`
}

func (UserAnime) IsEntity() {}

type AnimeSeasonStatus string

const (
	AnimeSeasonStatusUnknown   AnimeSeasonStatus = "UNKNOWN"
	AnimeSeasonStatusConfirmed AnimeSeasonStatus = "CONFIRMED"
	AnimeSeasonStatusAnnounced AnimeSeasonStatus = "ANNOUNCED"
	AnimeSeasonStatusCancelled AnimeSeasonStatus = "CANCELLED"
)

var AllAnimeSeasonStatus = []AnimeSeasonStatus{
	AnimeSeasonStatusUnknown,
	AnimeSeasonStatusConfirmed,
	AnimeSeasonStatusAnnounced,
	AnimeSeasonStatusCancelled,
}

func (e AnimeSeasonStatus) IsValid() bool {
	switch e {
	case AnimeSeasonStatusUnknown, AnimeSeasonStatusConfirmed, AnimeSeasonStatusAnnounced, AnimeSeasonStatusCancelled:
		return true
	}
	return false
}

func (e AnimeSeasonStatus) String() string {
	return string(e)
}

func (e *AnimeSeasonStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AnimeSeasonStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AnimeSeasonStatus", str)
	}
	return nil
}

func (e AnimeSeasonStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Season string

const (
	SeasonSpring2020 Season = "SPRING_2020"
	SeasonSummer2020 Season = "SUMMER_2020"
	SeasonFall2020   Season = "FALL_2020"
	SeasonWinter2020 Season = "WINTER_2020"
	SeasonSpring2021 Season = "SPRING_2021"
	SeasonSummer2021 Season = "SUMMER_2021"
	SeasonFall2021   Season = "FALL_2021"
	SeasonWinter2021 Season = "WINTER_2021"
	SeasonSpring2022 Season = "SPRING_2022"
	SeasonSummer2022 Season = "SUMMER_2022"
	SeasonFall2022   Season = "FALL_2022"
	SeasonWinter2022 Season = "WINTER_2022"
	SeasonSpring2023 Season = "SPRING_2023"
	SeasonSummer2023 Season = "SUMMER_2023"
	SeasonFall2023   Season = "FALL_2023"
	SeasonWinter2023 Season = "WINTER_2023"
	SeasonSpring2024 Season = "SPRING_2024"
	SeasonSummer2024 Season = "SUMMER_2024"
	SeasonFall2024   Season = "FALL_2024"
	SeasonWinter2024 Season = "WINTER_2024"
	SeasonSpring2025 Season = "SPRING_2025"
	SeasonSummer2025 Season = "SUMMER_2025"
	SeasonFall2025   Season = "FALL_2025"
	SeasonWinter2025 Season = "WINTER_2025"
)

var AllSeason = []Season{
	SeasonSpring2020,
	SeasonSummer2020,
	SeasonFall2020,
	SeasonWinter2020,
	SeasonSpring2021,
	SeasonSummer2021,
	SeasonFall2021,
	SeasonWinter2021,
	SeasonSpring2022,
	SeasonSummer2022,
	SeasonFall2022,
	SeasonWinter2022,
	SeasonSpring2023,
	SeasonSummer2023,
	SeasonFall2023,
	SeasonWinter2023,
	SeasonSpring2024,
	SeasonSummer2024,
	SeasonFall2024,
	SeasonWinter2024,
	SeasonSpring2025,
	SeasonSummer2025,
	SeasonFall2025,
	SeasonWinter2025,
}

func (e Season) IsValid() bool {
	switch e {
	case SeasonSpring2020, SeasonSummer2020, SeasonFall2020, SeasonWinter2020, SeasonSpring2021, SeasonSummer2021, SeasonFall2021, SeasonWinter2021, SeasonSpring2022, SeasonSummer2022, SeasonFall2022, SeasonWinter2022, SeasonSpring2023, SeasonSummer2023, SeasonFall2023, SeasonWinter2023, SeasonSpring2024, SeasonSummer2024, SeasonFall2024, SeasonWinter2024, SeasonSpring2025, SeasonSummer2025, SeasonFall2025, SeasonWinter2025:
		return true
	}
	return false
}

func (e Season) String() string {
	return string(e)
}

func (e *Season) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Season(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Season", str)
	}
	return nil
}

func (e Season) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
